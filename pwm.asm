;**********************************************************************
;Led headlamp
;PIC 16F684
;internal 4MHz
;------------------------------
; Jakub Kaderka
; jakub.kaderka@gmail.com
; 2015
;------------------------------
; pwm.asm
;------------------------------
; Pwm generator uses tmr0 interrupt which sets the pwm frequency (1024Hz),
; After the timer overflow, pwm outputs are driven to high or low, based
; on the pwm duties:
;	duty <= 50% : set pin to high
;	duty >= 50% : set pin to low
;
; Then after time given by pwm_time1 toggles pin which corresponds to
; shorted pulse and wait for pwm_time2 loops. Finally, the second pin
; is toggled and the interrupt routine ends.
;
; This design takes up to 50% of the processing (pwm at 50%) time without
; depending ; on precise timing of other system jobs.
;
;
; To make interrupt routine as short as possible, the necessary pin
; output values and timing variables are calculated by pwm_update routine
; only once per pwm duty update.
;
; As the voltage drops with battery closing to end of it's capacity,
; the voltage generated by pwm is also decreasing. Therefore the AD
; task measures voltage few times a second and calculates necessary
; correction to pwm duty to keep the voltage stable.
;**********************************************************************

;-----------------------------------
; Update pwm generator duties
;
; calculate variables for pwm generator (based on pwm_dutyX)
; and update them when finished
;
; Generates shorter part of the pulse:
;	duty <= 50% : generate high part of pulse
;	duty >= 50% : generate low part of pulse
;
; Calculated values sets the time of the shorter pulse (pwm_time1)
; and the difference between shorter and longer part (pwm_time2)
;
; States of the outputs in each of the three parts of the pwm
; executions (initial, firts pulse finished, second finished)
; are stored in pwm_data
;
; disables interrupts momentarily
;-----------------------------------
pwm_update
	clrf	pwm_tmp_data

;first get initial values and timing of shorter part of the pulse
	movlw	PWM_DUTY_HALF
	subwf	pwm_duty1, w		;compare 50% and actual value
	btfsc	status, c
	goto	pwm_update_2		;over 50%

	bsf	pwm_tmp_data, pstart1	;under 50%
	movf	pwm_duty1, w
	movwf	pwm_tmp1		;just copy the duty for further computation

pwm_update_1
	movlw	PWM_DUTY_HALF
	subwf	pwm_duty2, w		;compare 50% and actual value
	btfsc	status, c
	goto	pwm_update_3		;over 50%

	bsf	pwm_tmp_data, pstart2	;under 50%
	movf	pwm_duty2, w
	movwf	pwm_tmp2		;just copy the duty for further computation

	goto	pwm_update_4

;duty1 over 50
pwm_update_2
	movf	pwm_duty1, w
	sublw	PWM_DUTY_FULL	;PWM_DUTY_FULL - pwm_duty
	movwf	pwm_tmp1
	goto	pwm_update_1

;duty2 over 50
pwm_update_3
	movf	pwm_duty2, w
	sublw	PWM_DUTY_FULL	;PWM_DUTY_FULL - pwm_duty
	movwf	pwm_tmp2

;first bits and times are ready, compute middle and end bits
pwm_update_4
	movf	pwm_tmp1, w
	subwf	pwm_tmp2, w		;tmp2 - tmp1
	btfsc	status, z
	goto	pwm_update_same		;tmp2 == tmp1

	btfss	status, c
	goto	pwm_update_5		;tmp1 > tmp2
;tmp1 < tmp2
	PWM_TOGGLE_CONF pmiddle1, pstart1
	PWM_COPY_CONF	pmiddle2, pstart2
	PWM_TOGGLE_CONF pend2, pmiddle2
	PWM_COPY_CONF	pend1, pmiddle1

	movf	pwm_tmp1, w
	movwf	pwm_tmp_time1		;update shorter pulse time

	subwf	pwm_tmp2, w
	movwf	pwm_tmp_time2		;tmp2-tmp1
	goto	pwm_update_var		;set the permanent values and return

;tmp1 > tmp2
pwm_update_5
	PWM_TOGGLE_CONF pmiddle2, pstart2
	PWM_COPY_CONF	pmiddle1, pstart1
	PWM_TOGGLE_CONF pend1, pmiddle1
	PWM_COPY_CONF	pend2, pmiddle2

	movf	pwm_tmp2, w
	movwf	pwm_tmp_time1		;update shorter pulse time

	subwf	pwm_tmp1, w
	movwf	pwm_tmp_time2		;tmp1-tmp2
	goto	pwm_update_var		;set the permanent values and return

;both pwm times are same
pwm_update_same
	PWM_TOGGLE_CONF	pmiddle1, pstart1
	PWM_TOGGLE_CONF	pmiddle2, pstart2
	PWM_COPY_CONF	pend1, pmiddle1
	PWM_COPY_CONF	pend2, pmiddle2	;toggle middle and copy middle to end
	clrf	pwm_tmp_time2
	movf	pwm_tmp1, w
	movwf	pwm_tmp_time1		;update time1 to pulse length and time2 to 0
	goto	pwm_update_var		;finally, update the real pwm values

;finally, copy values from tmp to permanent locations
;additionally, check for 100% or 0% duty cycles and update the data parts
;disables interrupts mometarily!
pwm_update_var
;final checks, fix the max/min duty variables
	movf	pwm_tmp1, f
	btfsc	status, z
	goto	pwm_update_var_1	;pwm1 is 100% or 0%
pwm_update_var_3
	movf	pwm_tmp2, f
	btfsc	status, z
	goto	pwm_update_var_2

pwm_update_var_4
;update the times to avoid owerflow - pwm generator first do decfsz...
	incf	pwm_tmp_time1, w
	btfss	status, z		;check if incrementing wont't cause buffer overflow
	incf	pwm_tmp_time1, f

	incf	pwm_tmp_time2, w
	btfss	status, z
	incf	pwm_tmp_time2, f
;disable interrupts and copy data to the permanent location
	bcf	intcon, gie		;disable interrupt
	movf	pwm_tmp_data, w
	movwf	pwm_data
	movf	pwm_tmp_time1, w
	movwf	pwm_time1
	movf	pwm_tmp_time2, w
	movwf	pwm_time2		;copy data
	bsf	intcon, gie		;reenable interrupt
	return

;pwm 1 on 100% or 0%
pwm_update_var_1
	PWM_TOGGLE_CONF	pstart1, pstart1
	PWM_COPY_CONF	pmiddle1, pstart1
	PWM_COPY_CONF	pend1, pmiddle1
	goto		pwm_update_var_3

;pwm 2 on 100% or 0%
pwm_update_var_2
	PWM_TOGGLE_CONF	pstart2, pstart2
	PWM_COPY_CONF	pmiddle2, pstart2
	PWM_COPY_CONF	pend2, pmiddle2
	goto		pwm_update_var_4

;-----------------------------------
; Limit value in W to PWM_DUTY_FULL
; uses tmp
;-----------------------------------
pwm_duty_limit
	movwf	tmp
	sublw	PWM_DUTY_FULL		;full - new
	btfss	status, c
	retlw	PWM_DUTY_FULL		;new > full
	movf	tmp, w
	return

;-----------------------------------
; Set pwm1 duty from W
; pwm_update must to be called to apply this change
;
; uses tmp and 1 level stack
;-----------------------------------
pwm1_set
	call	pwm_duty_limit
	movwf	pwm_duty1
	return

;-----------------------------------
; Set pwm2 duty from W
; pwm_update must to be called to apply this change
;
; uses tmp and 1 level stack
;-----------------------------------
pwm2_set
	call	pwm_duty_limit
	movwf	pwm_duty2
	return
